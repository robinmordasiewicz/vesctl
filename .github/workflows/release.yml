name: Release

on:
  push:
    branches:
      - main

# Cancel in-progress runs when a new run is triggered
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            code:
              - '**.ts'
              - '**.tsx'
              - 'package.json'
              - 'package-lock.json'

      - name: Set up Node.js
        if: steps.changes.outputs.code == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        if: steps.changes.outputs.code == 'true'
        run: npm ci

      - name: Run tests
        if: steps.changes.outputs.code == 'true'
        run: npm test

      - name: Run type check
        if: steps.changes.outputs.code == 'true'
        run: npm run typecheck

  version:
    name: Generate Version
    runs-on: ubuntu-latest
    needs: test
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download latest specs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./scripts/download-specs.sh

      - name: Generate version from upstream API version
        id: version
        run: |
          # Get upstream API version from specs
          UPSTREAM_VERSION=$(jq -r '.version' .specs/index.json)
          echo "Upstream API version: $UPSTREAM_VERSION"

          # Generate YYMMDDHHMM timestamp (UTC)
          TIMESTAMP=$(date -u +"%y%m%d%H%M")
          echo "Timestamp: $TIMESTAMP"

          # Construct version: v{upstream}-{timestamp}
          VERSION="v${UPSTREAM_VERSION}-${TIMESTAMP}"
          echo "Generated version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Verify version is unique
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if git tag -l "$VERSION" | grep -q "$VERSION"; then
            echo "Error: Tag $VERSION already exists"
            exit 1
          fi
          echo "Tag $VERSION is unique, proceeding..."

      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.version.outputs.version }}" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "${{ steps.version.outputs.version }}"

  # Build binaries on native platforms to avoid cross-compilation issues
  # Bun cross-compilation does not work reliably (especially for macOS)
  build-linux:
    name: Build Linux Binaries
    runs-on: ubuntu-latest
    needs: version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download enriched API specifications
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./scripts/download-specs.sh

      - name: Build TypeScript
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          XCSH_VERSION: ${{ needs.version.outputs.version }}
        run: npm run build

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Build Linux binaries
        run: ./scripts/build-binaries.sh --platform linux

      - name: Upload Linux binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries-linux
          path: binaries/
          retention-days: 1

  build-macos:
    name: Build macOS Binaries
    runs-on: macos-latest
    needs: version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download enriched API specifications
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./scripts/download-specs.sh

      - name: Build TypeScript
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          XCSH_VERSION: ${{ needs.version.outputs.version }}
        run: npm run build

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Build macOS binaries
        run: ./scripts/build-binaries.sh --platform darwin

      - name: Upload macOS binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries-macos
          path: binaries/
          retention-days: 1

  build-windows:
    name: Build Windows Binaries
    runs-on: windows-latest
    needs: version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download enriched API specifications
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./scripts/download-specs.sh

      - name: Build TypeScript
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          XCSH_VERSION: ${{ needs.version.outputs.version }}
        run: npm run build

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Build Windows binaries
        shell: bash
        run: ./scripts/build-binaries.sh --platform windows

      - name: Upload Windows binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries-windows
          path: binaries/
          retention-days: 1

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [version, build-linux, build-macos, build-windows]
    outputs:
      version: ${{ needs.version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Generate fresh completions
        run: npm run generate:completions

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: binaries
          merge-multiple: true

      - name: List downloaded binaries
        run: ls -la binaries/

      - name: Create release archives
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          mkdir -p release-archives

          # Create archives for each platform (includes completions)
          for file in binaries/*; do
            filename=$(basename "$file")

            case "$filename" in
              *-linux-x64)
                ARCHIVE_NAME="xcsh_${VERSION}_linux_amd64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh completions/
                rm xcsh
                ;;
              *-linux-arm64)
                ARCHIVE_NAME="xcsh_${VERSION}_linux_arm64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh completions/
                rm xcsh
                ;;
              *-macos-x64)
                ARCHIVE_NAME="xcsh_${VERSION}_darwin_amd64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh completions/
                rm xcsh
                ;;
              *-macos-arm64)
                ARCHIVE_NAME="xcsh_${VERSION}_darwin_arm64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh completions/
                rm xcsh
                ;;
              *-win-x64.exe)
                ARCHIVE_NAME="xcsh_${VERSION}_windows_amd64.zip"
                mv "$file" xcsh.exe
                zip -r "release-archives/${ARCHIVE_NAME}" xcsh.exe completions/
                rm xcsh.exe
                ;;
              *-win-arm64.exe)
                ARCHIVE_NAME="xcsh_${VERSION}_windows_arm64.zip"
                mv "$file" xcsh.exe
                zip -r "release-archives/${ARCHIVE_NAME}" xcsh.exe completions/
                rm xcsh.exe
                ;;
            esac
          done

          ls -la release-archives/

      - name: Generate checksums
        run: |
          cd release-archives
          shasum -a 256 * > checksums.txt
          cat checksums.txt

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.version.outputs.version }}"

          # Create release notes
          cat > release-notes.md << 'RELEASE_EOF'
          ## xcsh ${VERSION}

          ### Installation

          **macOS (Apple Silicon)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/${VERSION}/xcsh_${VERSION}_darwin_arm64.tar.gz
          tar -xzf xcsh_${VERSION}_darwin_arm64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **macOS (Intel)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/${VERSION}/xcsh_${VERSION}_darwin_amd64.tar.gz
          tar -xzf xcsh_${VERSION}_darwin_amd64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **Linux (amd64)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/${VERSION}/xcsh_${VERSION}_linux_amd64.tar.gz
          tar -xzf xcsh_${VERSION}_linux_amd64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **Linux (arm64)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/${VERSION}/xcsh_${VERSION}_linux_arm64.tar.gz
          tar -xzf xcsh_${VERSION}_linux_arm64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **Windows (amd64)**
          Download `xcsh_${VERSION}_windows_amd64.zip` and extract to your PATH.

          **npm (requires Node.js)**
          ```bash
          npm install -g @robinmordasiewicz/f5xc-xcsh
          ```

          **npx (no installation)**
          ```bash
          npx @robinmordasiewicz/f5xc-xcsh
          ```
          RELEASE_EOF

          # Substitute version in release notes
          sed -i "s/\${VERSION}/${VERSION}/g" release-notes.md

          # Create GitHub release
          gh release create "${VERSION}" \
            --title "xcsh ${VERSION}" \
            --notes-file release-notes.md \
            release-archives/*

  publish-npm:
    name: Publish to npm
    runs-on: ubuntu-latest
    needs: create-release
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          registry-url: "https://registry.npmjs.org"

      - name: Install dependencies
        run: npm ci

      - name: Download enriched API specifications
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./scripts/download-specs.sh

      - name: Build
        run: npm run build
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          XCSH_VERSION: ${{ needs.create-release.outputs.version }}

      - name: Set package version
        run: |
          # Strip leading 'v' for npm (v1.0.78-2501010830 -> 1.0.78-2501010830)
          VERSION="${{ needs.create-release.outputs.version }}"
          NPM_VERSION="${VERSION#v}"
          echo "Setting npm version to: $NPM_VERSION"
          npm version "$NPM_VERSION" --no-git-tag-version

      - name: Publish to npm
        run: npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  sign-macos:
    name: Sign macOS Binaries
    runs-on: macos-latest
    needs: create-release
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Import Code Signing Certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Store for later steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          # Decode certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          echo "Certificate decoded, checking..."

          # Verify p12 is valid
          openssl pkcs12 -info -in $RUNNER_TEMP/certificate.p12 -noout -passin pass:"$APPLE_CERTIFICATE_PASSWORD" || {
            echo "ERROR: Invalid p12 file or wrong password"
            exit 1
          }

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security default-keychain -s $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate with proper options
          echo "Importing certificate..."
          security import $RUNNER_TEMP/certificate.p12 \
            -k $KEYCHAIN_PATH \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Add to search list
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Verify import worked
          echo "Verifying certificate import..."
          security find-identity -v -p codesigning $KEYCHAIN_PATH

          # Clean up certificate file
          rm $RUNNER_TEMP/certificate.p12

      - name: Download and Sign macOS Binaries
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Signing version: $VERSION"

          # Retry function with exponential backoff
          retry_with_backoff() {
            local max_attempts=5
            local base_delay=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if "$@"; then
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                delay=$((base_delay * (2 ** (attempt - 1))))
                echo "::warning::Attempt $attempt failed, retrying in ${delay}s..."
                sleep $delay
              fi
              attempt=$((attempt + 1))
            done

            echo "::error::All $max_attempts attempts failed"
            return 1
          }

          # Unlock keychain for this step
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Find the Developer ID Application certificate from our keychain
          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "ERROR: No Developer ID signing identity found"
            exit 1
          fi
          echo "Using signing identity: $SIGNING_IDENTITY"

          # Process each macOS architecture
          for ARCH in amd64 arm64; do
            ASSET_NAME="xcsh_${VERSION}_darwin_${ARCH}.tar.gz"
            echo "Processing $ASSET_NAME..."

            # Download release asset with retry
            retry_with_backoff gh release download "${VERSION}" -p "$ASSET_NAME" -D $RUNNER_TEMP

            # Extract
            mkdir -p $RUNNER_TEMP/sign_${ARCH}
            tar -xzf $RUNNER_TEMP/$ASSET_NAME -C $RUNNER_TEMP/sign_${ARCH}

            # Sign the binary
            BINARY_PATH="$RUNNER_TEMP/sign_${ARCH}/xcsh"
            echo "Signing $BINARY_PATH..."

            codesign --force --options runtime --entitlements scripts/entitlements.plist --sign "$SIGNING_IDENTITY" --timestamp "$BINARY_PATH"

            # Health Check 1: Verify code signature
            echo "Health Check 1: Verifying code signature..."
            codesign --verify --verbose "$BINARY_PATH" || {
              echo "::error::Code signature verification failed for $ARCH"
              exit 1
            }

            # Health Check 2: Verify Developer ID authority chain
            echo "Health Check 2: Verifying Developer ID authority chain..."
            AUTHORITY=$(codesign -dvvv "$BINARY_PATH" 2>&1 | grep "Authority=Developer ID Application" || true)
            if [ -z "$AUTHORITY" ]; then
              echo "::error::Binary not signed with Developer ID Application certificate"
              exit 1
            fi
            echo "  ✓ Signed with: $AUTHORITY"

            # Health Check 3: Verify hardened runtime is enabled
            echo "Health Check 3: Verifying hardened runtime..."
            FLAGS=$(codesign -dvvv "$BINARY_PATH" 2>&1 | grep "flags=" || true)
            if ! echo "$FLAGS" | grep -q "runtime"; then
              echo "::error::Hardened runtime not enabled"
              exit 1
            fi
            echo "  ✓ Hardened runtime enabled"

            # Create ZIP for notarization
            ZIP_PATH="$RUNNER_TEMP/xcsh_${ARCH}.zip"
            ditto -c -k --keepParent "$BINARY_PATH" "$ZIP_PATH"

            # Submit for notarization and wait for completion
            echo "Submitting for notarization..."
            NOTARY_OUTPUT=$(xcrun notarytool submit "$ZIP_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait 2>&1)
            echo "$NOTARY_OUTPUT"

            # Health Check 4: Verify notarization succeeded
            echo "Health Check 4: Verifying notarization status..."
            if ! echo "$NOTARY_OUTPUT" | grep -q "status: Accepted"; then
              echo "::error::Notarization failed or not accepted for $ARCH"
              echo "$NOTARY_OUTPUT"
              exit 1
            fi
            echo "  ✓ Notarization accepted"

            # Attempt to staple the notarization ticket to the binary
            # Note: Bare Mach-O command-line binaries (like xcsh) cannot be stapled (Error 73)
            # Only .app bundles, .dmg, and .pkg files support stapling
            # Without stapling, Gatekeeper will verify notarization online (requires network)
            echo "Health Check 5: Attempting to staple notarization ticket..."
            STAPLE_OUTPUT=$(xcrun stapler staple "$BINARY_PATH" 2>&1) || true
            if echo "$STAPLE_OUTPUT" | grep -q "The staple and validate action worked"; then
              echo "  ✓ Notarization ticket stapled successfully"
            else
              echo "  ⚠ Stapling not supported for bare Mach-O binaries (expected for CLI tools)"
              echo "  Note: Binary is signed and notarized - Gatekeeper will verify online"
              echo "  Stapler output: $STAPLE_OUTPUT"
            fi

            echo "✓ All health checks passed for $ARCH"

            # Repackage as tar.gz
            cd $RUNNER_TEMP/sign_${ARCH}
            tar -czf $RUNNER_TEMP/${ASSET_NAME} *
            cd -

            # Upload signed binary to release (replace unsigned)
            echo "Uploading signed $ASSET_NAME..."
            gh release upload "${VERSION}" $RUNNER_TEMP/$ASSET_NAME --clobber
          done

          echo "macOS binaries signed and uploaded successfully!"

      - name: Regenerate checksums.txt with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Regenerating checksums.txt for version $VERSION..."

          # Retry function with exponential backoff
          retry_with_backoff() {
            local max_attempts=5
            local base_delay=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if "$@"; then
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                delay=$((base_delay * (2 ** (attempt - 1))))
                echo "::warning::Attempt $attempt failed, retrying in ${delay}s..."
                sleep $delay
              fi
              attempt=$((attempt + 1))
            done

            echo "::error::All $max_attempts attempts failed"
            return 1
          }

          # Create working directory
          mkdir -p $RUNNER_TEMP/checksums
          cd $RUNNER_TEMP/checksums

          # Download all release assets with retry
          echo "Downloading all release assets..."
          retry_with_backoff sh -c "GH_TOKEN=\"\$GITHUB_TOKEN\" gh release download \"${VERSION}\" --repo \"${{ github.repository }}\""

          # Generate new checksums.txt
          echo "Computing SHA256 checksums..."
          shasum -a 256 xcsh_${VERSION}_*.tar.gz xcsh_${VERSION}_*.zip 2>/dev/null | tee checksums.txt

          # Upload new checksums.txt to replace the old one
          echo "Uploading updated checksums.txt..."
          GH_TOKEN="$GITHUB_TOKEN" gh release upload "${VERSION}" checksums.txt --clobber --repo "${{ github.repository }}"

          echo "checksums.txt regenerated successfully!"

      - name: Update Homebrew cask with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"

          echo "Computing SHA256 hashes for all release assets..."

          # Retry function with exponential backoff
          retry_with_backoff() {
            local max_attempts=5
            local base_delay=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if "$@"; then
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                delay=$((base_delay * (2 ** (attempt - 1))))
                echo "::warning::Attempt $attempt failed, retrying in ${delay}s..."
                sleep $delay
              fi
              attempt=$((attempt + 1))
            done

            echo "::error::All $max_attempts attempts failed"
            return 1
          }

          # Download all release tarballs and compute hashes
          mkdir -p $RUNNER_TEMP/hash_check
          cd $RUNNER_TEMP/hash_check

          # Download and compute hash for each platform
          for PLATFORM in darwin_amd64 darwin_arm64 linux_amd64 linux_arm64; do
            ASSET="xcsh_${VERSION}_${PLATFORM}.tar.gz"
            echo "Downloading $ASSET..."
            retry_with_backoff sh -c "GH_TOKEN=\"\$GITHUB_TOKEN\" gh release download \"${VERSION}\" --pattern \"$ASSET\" --repo \"${{ github.repository }}\""
            HASH=$(shasum -a 256 "$ASSET" | cut -d' ' -f1)
            export "HASH_${PLATFORM}=${HASH}"
            echo "$PLATFORM: $HASH"
          done

          # Clone homebrew-tap and update cask
          cd $RUNNER_TEMP
          git clone https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/robinmordasiewicz/homebrew-tap.git
          cd homebrew-tap

          # Update the cask file with correct hashes
          cat > Casks/xcsh.rb << CASKEOF
          cask "xcsh" do
            name "xcsh"
            desc "Command-line interface for F5 Distributed Cloud"
            homepage "https://robinmordasiewicz.github.io/f5xc-xcsh"
            version "${VERSION}"

            livecheck do
              skip "Auto-generated on release."
            end

            binary "xcsh"

            # Install shell completions and check for conflicts
            postflight do
              # Bash completions
              bash_completion = "#{HOMEBREW_PREFIX}/etc/bash_completion.d"
              system_command "/bin/mkdir", args: ["-p", bash_completion]
              system_command "/bin/cp", args: ["#{staged_path}/completions/xcsh.bash", "#{bash_completion}/xcsh"]

              # Zsh completions
              zsh_completion = "#{HOMEBREW_PREFIX}/share/zsh/site-functions"
              system_command "/bin/mkdir", args: ["-p", zsh_completion]
              system_command "/bin/cp", args: ["#{staged_path}/completions/_xcsh", zsh_completion]

              # Fish completions
              fish_completion = "#{HOMEBREW_PREFIX}/share/fish/vendor_completions.d"
              system_command "/bin/mkdir", args: ["-p", fish_completion]
              system_command "/bin/cp", args: ["#{staged_path}/completions/xcsh.fish", fish_completion]

              # Check for conflicting installations
              conflict_locations = [
                File.expand_path("~/.local/bin/xcsh"),
                "/usr/local/bin/xcsh"
              ]
              conflicts = conflict_locations.select { |path| File.exist?(path) }
              unless conflicts.empty?
                opoo "Conflicting xcsh installations detected:"
                conflicts.each { |path| opoo "  #{path}" }
                opoo "These may shadow the Homebrew installation."
                opoo "Run: which xcsh && xcsh --version"
              end
            end

            uninstall_postflight do
              # Clean up shell completions
              system_command "/bin/rm", args: ["-f", "#{HOMEBREW_PREFIX}/etc/bash_completion.d/xcsh"]
              system_command "/bin/rm", args: ["-f", "#{HOMEBREW_PREFIX}/share/zsh/site-functions/_xcsh"]
              system_command "/bin/rm", args: ["-f", "#{HOMEBREW_PREFIX}/share/fish/vendor_completions.d/xcsh.fish"]

              # Check for other installations that may still exist
              other_locations = [
                File.expand_path("~/.local/bin/xcsh"),
                "/usr/local/bin/xcsh"
              ]
              remaining = other_locations.select { |path| File.exist?(path) }
              unless remaining.empty?
                opoo "Other xcsh installations still exist:"
                remaining.each { |path| opoo "  #{path}" }
                opoo "To completely remove xcsh, also delete these files."
              end
            end

            on_macos do
              on_intel do
                url "https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/#{version}/xcsh_#{version}_darwin_amd64.tar.gz"
                sha256 "${HASH_darwin_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/#{version}/xcsh_#{version}_darwin_arm64.tar.gz"
                sha256 "${HASH_darwin_arm64}"
              end
            end

            on_linux do
              on_intel do
                url "https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/#{version}/xcsh_#{version}_linux_amd64.tar.gz"
                sha256 "${HASH_linux_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/f5xc-xcsh/releases/download/#{version}/xcsh_#{version}_linux_arm64.tar.gz"
                sha256 "${HASH_linux_arm64}"
              end
            end

            caveats <<~EOS
              xcsh has been installed to #{HOMEBREW_PREFIX}/bin/xcsh

              Shell completions have been installed for bash, zsh, and fish.
              You may need to restart your shell or source your shell config.

              PATH CONFLICT CHECK:
              If you previously installed xcsh via install.sh or another method,
              verify which version is active:
                which xcsh && xcsh --version

              If the active binary is not in #{HOMEBREW_PREFIX}/bin, you may have
              a conflicting installation. Remove old binaries from:
                ~/.local/bin/xcsh
                /usr/local/bin/xcsh

              For setup instructions, see:
                https://robinmordasiewicz.github.io/f5xc-xcsh/install/homebrew/

              Quick start:
                xcsh --help
            EOS
          end
          CASKEOF

          # Remove leading whitespace from heredoc
          sed -i '' 's/^          //' Casks/xcsh.rb

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Casks/xcsh.rb
          git commit -m "chore: Update xcsh cask to ${VERSION}"
          git push
