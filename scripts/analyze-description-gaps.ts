#!/usr/bin/env npx tsx
/**
 * Description Gap Analysis Script
 *
 * Analyzes upstream API specifications to identify missing or generic descriptions
 * that should be improved in the upstream f5xc-api-enriched repository.
 *
 * Detection criteria:
 * - Generic descriptions matching "F5 Distributed Cloud {Domain} API specifications"
 * - Missing 3-tier differentiation (description_short = description)
 * - Auto-generated summaries matching "{Action} {Resource}."
 * - Missing x-f5xc-operation-metadata
 *
 * Output: Markdown report for creating GitHub issues in upstream repo
 *
 * Run: npx tsx scripts/analyze-description-gaps.ts
 */

import * as fs from "fs";
import * as path from "path";

// Types
interface SpecIndexEntry {
	domain: string;
	title: string;
	description: string;
	description_short: string;
	description_medium: string;
}

interface SpecIndex {
	version: string;
	specifications: SpecIndexEntry[];
}

interface OpenAPIOperation {
	summary?: string;
	description?: string;
	operationId?: string;
	"x-f5xc-operation-metadata"?: {
		purpose?: string;
	};
}

interface OpenAPIPathItem {
	get?: OpenAPIOperation;
	post?: OpenAPIOperation;
	put?: OpenAPIOperation;
	delete?: OpenAPIOperation;
	patch?: OpenAPIOperation;
}

interface OpenAPISpec {
	info: {
		title: string;
		description: string;
	};
	paths: Record<string, OpenAPIPathItem>;
}

interface DomainGap {
	domain: string;
	issues: string[];
	severity: "high" | "medium" | "low";
}

interface OperationGap {
	domain: string;
	path: string;
	method: string;
	operationId: string;
	issues: string[];
}

// Generic description patterns to detect
const GENERIC_PATTERNS = [
	/^F5 Distributed Cloud .* API specifications?\.?$/i,
	/^API specifications? for .*\.?$/i,
	/^Manage .* resources\.?$/i,
	/^The .* API\.?$/i,
];

// Auto-generated summary patterns
const AUTO_SUMMARY_PATTERNS = [
	/^(Create|Get|List|Delete|Replace|Update) [A-Z][a-z]+\.?$/,
	/^(Create|Get|List|Delete|Replace) [A-Z][a-z]+ [A-Z][a-z]+\.?$/,
];

/**
 * Check if a description is generic/placeholder
 */
function isGenericDescription(desc: string): boolean {
	if (!desc || desc.length < 20) return true;

	for (const pattern of GENERIC_PATTERNS) {
		if (pattern.test(desc)) return true;
	}

	return false;
}

/**
 * Check if a summary is auto-generated
 */
function isAutoGeneratedSummary(summary: string): boolean {
	if (!summary) return true;

	for (const pattern of AUTO_SUMMARY_PATTERNS) {
		if (pattern.test(summary)) return true;
	}

	return false;
}

/**
 * Check if 3-tier descriptions are properly differentiated
 */
function hasProperDifferentiation(entry: SpecIndexEntry): boolean {
	// All three tiers should be different
	if (entry.description_short === entry.description) return false;
	if (entry.description_short === entry.description_medium) return false;

	// Short should be shorter than medium
	if (entry.description_short.length >= entry.description_medium.length)
		return false;

	// Medium should be shorter than long
	if (entry.description_medium.length >= entry.description.length) return false;

	return true;
}

/**
 * Analyze domain-level description quality
 */
function analyzeDomainDescriptions(index: SpecIndex): DomainGap[] {
	const gaps: DomainGap[] = [];

	for (const entry of index.specifications) {
		const issues: string[] = [];

		// Check for generic description
		if (isGenericDescription(entry.description)) {
			issues.push("Long description is generic/placeholder");
		}

		// Check for proper 3-tier differentiation
		if (!hasProperDifferentiation(entry)) {
			issues.push("3-tier descriptions not properly differentiated");
		}

		// Check character limits
		if (entry.description_short.length > 60) {
			issues.push(`Short description exceeds 60 chars (${entry.description_short.length})`);
		}
		if (entry.description_medium.length > 150) {
			issues.push(`Medium description exceeds 150 chars (${entry.description_medium.length})`);
		}

		if (issues.length > 0) {
			const severity =
				issues.length >= 2
					? "high"
					: issues.some((i) => i.includes("generic"))
						? "medium"
						: "low";

			gaps.push({
				domain: entry.domain,
				issues,
				severity,
			});
		}
	}

	return gaps;
}

/**
 * Analyze operation-level description quality
 */
function analyzeOperationDescriptions(specsDir: string): OperationGap[] {
	const gaps: OperationGap[] = [];

	const specFiles = fs
		.readdirSync(specsDir)
		.filter((f) => f.endsWith(".json"))
		.sort();

	for (const specFile of specFiles) {
		const specPath = path.join(specsDir, specFile);
		let spec: OpenAPISpec;

		try {
			const content = fs.readFileSync(specPath, "utf-8");
			spec = JSON.parse(content);
		} catch {
			continue;
		}

		const domain = path.basename(specFile, ".json");

		for (const [pathPattern, pathItem] of Object.entries(spec.paths)) {
			if (!pathItem || typeof pathItem !== "object") continue;

			const methods: Array<[string, OpenAPIOperation | undefined]> = [
				["get", pathItem.get],
				["post", pathItem.post],
				["put", pathItem.put],
				["delete", pathItem.delete],
				["patch", pathItem.patch],
			];

			for (const [method, operation] of methods) {
				if (!operation) continue;

				const issues: string[] = [];

				// Check for auto-generated summary
				if (operation.summary && isAutoGeneratedSummary(operation.summary)) {
					issues.push("Summary appears auto-generated");
				}

				// Check for missing or very short description
				if (!operation.description || operation.description.length < 30) {
					issues.push("Description missing or too short");
				}

				// Check for missing x-f5xc-operation-metadata
				if (!operation["x-f5xc-operation-metadata"]?.purpose) {
					issues.push("Missing x-f5xc-operation-metadata.purpose");
				}

				if (issues.length > 0) {
					gaps.push({
						domain,
						path: pathPattern,
						method,
						operationId: operation.operationId || "unknown",
						issues,
					});
				}
			}
		}
	}

	return gaps;
}

/**
 * Generate markdown report
 */
function generateReport(
	domainGaps: DomainGap[],
	operationGaps: OperationGap[],
	specVersion: string,
): string {
	const lines: string[] = [];

	lines.push("# Description Gap Analysis Report");
	lines.push("");
	lines.push(`**Generated**: ${new Date().toISOString()}`);
	lines.push(`**Spec Version**: ${specVersion}`);
	lines.push("");

	// Summary
	const highSeverity = domainGaps.filter((g) => g.severity === "high").length;
	const mediumSeverity = domainGaps.filter((g) => g.severity === "medium").length;
	const lowSeverity = domainGaps.filter((g) => g.severity === "low").length;

	lines.push("## Summary");
	lines.push("");
	lines.push(`- **Domain-level gaps**: ${domainGaps.length}`);
	lines.push(`  - High severity: ${highSeverity}`);
	lines.push(`  - Medium severity: ${mediumSeverity}`);
	lines.push(`  - Low severity: ${lowSeverity}`);
	lines.push(`- **Operation-level gaps**: ${operationGaps.length}`);
	lines.push("");

	// Domain gaps by severity
	if (domainGaps.length > 0) {
		lines.push("## Domain-Level Gaps");
		lines.push("");

		for (const severity of ["high", "medium", "low"] as const) {
			const sevGaps = domainGaps.filter((g) => g.severity === severity);
			if (sevGaps.length === 0) continue;

			lines.push(`### ${severity.charAt(0).toUpperCase() + severity.slice(1)} Severity`);
			lines.push("");

			for (const gap of sevGaps) {
				lines.push(`#### \`${gap.domain}\``);
				lines.push("");
				for (const issue of gap.issues) {
					lines.push(`- ${issue}`);
				}
				lines.push("");
			}
		}
	}

	// Operation gaps (grouped by domain)
	if (operationGaps.length > 0) {
		lines.push("## Operation-Level Gaps");
		lines.push("");
		lines.push("Operations missing quality descriptions or metadata.");
		lines.push("");

		// Group by domain
		const byDomain = new Map<string, OperationGap[]>();
		for (const gap of operationGaps) {
			if (!byDomain.has(gap.domain)) {
				byDomain.set(gap.domain, []);
			}
			byDomain.get(gap.domain)?.push(gap);
		}

		// Only show domains with significant gaps (>5 operations)
		const sortedDomains = Array.from(byDomain.entries())
			.filter(([, gaps]) => gaps.length > 5)
			.sort((a, b) => b[1].length - a[1].length)
			.slice(0, 10);

		for (const [domain, gaps] of sortedDomains) {
			lines.push(`### \`${domain}\` (${gaps.length} operations)`);
			lines.push("");
			lines.push("| Path | Method | Issues |");
			lines.push("|------|--------|--------|");

			for (const gap of gaps.slice(0, 10)) {
				const issuesSummary = gap.issues.join("; ");
				lines.push(`| \`${gap.path.slice(0, 50)}...\` | ${gap.method.toUpperCase()} | ${issuesSummary} |`);
			}

			if (gaps.length > 10) {
				lines.push(`| ... | ... | *(${gaps.length - 10} more)* |`);
			}
			lines.push("");
		}
	}

	// Recommendations
	lines.push("## Recommendations");
	lines.push("");
	lines.push("### For Upstream Repository (f5xc-api-enriched)");
	lines.push("");
	lines.push("1. **High severity domains** should be prioritized for description improvement");
	lines.push("2. Add `x-f5xc-operation-metadata.purpose` to operations missing it");
	lines.push("3. Ensure 3-tier descriptions are properly differentiated:");
	lines.push("   - `description_short`: ~60 characters, action-oriented");
	lines.push("   - `description_medium`: ~150 characters, adds context");
	lines.push("   - `description`: ~500 characters, comprehensive details");
	lines.push("4. Replace auto-generated summaries with meaningful descriptions");
	lines.push("");

	return lines.join("\n");
}

/**
 * Main function
 */
async function main(): Promise<void> {
	console.log("üîç Analyzing description gaps in upstream specs...");

	const specsDir = ".specs";
	const indexPath = path.join(specsDir, "index.json");
	const domainsDir = path.join(specsDir, "domains");
	const outputPath = path.join("docs", "description-gaps.md");

	// Check if specs exist
	if (!fs.existsSync(indexPath)) {
		console.error(`‚ùå Spec index not found: ${indexPath}`);
		console.error("   Run 'make download-specs' first.");
		process.exit(1);
	}

	// Load index
	const indexData = fs.readFileSync(indexPath, "utf-8");
	const index: SpecIndex = JSON.parse(indexData);
	console.log(`‚úì Loaded spec index v${index.version}`);

	// Analyze domain descriptions
	console.log("  Analyzing domain-level descriptions...");
	const domainGaps = analyzeDomainDescriptions(index);
	console.log(`  Found ${domainGaps.length} domains with gaps`);

	// Analyze operation descriptions
	console.log("  Analyzing operation-level descriptions...");
	const operationGaps = analyzeOperationDescriptions(domainsDir);
	console.log(`  Found ${operationGaps.length} operations with gaps`);

	// Generate report
	const report = generateReport(domainGaps, operationGaps, index.version);

	// Ensure output directory exists
	const outputDir = path.dirname(outputPath);
	if (!fs.existsSync(outputDir)) {
		fs.mkdirSync(outputDir, { recursive: true });
	}

	// Write report
	fs.writeFileSync(outputPath, report, "utf-8");
	console.log(`‚úì Report generated: ${outputPath}`);

	// Summary
	console.log("");
	console.log("üìä Gap Analysis Summary:");
	console.log(`   Domain-level gaps: ${domainGaps.length}`);
	console.log(`   Operation-level gaps: ${operationGaps.length}`);

	if (domainGaps.filter((g) => g.severity === "high").length > 0) {
		console.log("");
		console.log("‚ö†Ô∏è  High severity gaps found - consider creating upstream issues");
	}

	console.log("");
	console.log("‚úÖ Gap analysis complete!");
}

main().catch((err) => {
	console.error("‚ùå Analysis failed:", err);
	process.exit(1);
});
